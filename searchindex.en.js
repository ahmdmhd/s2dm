var relearn_searchindex = [
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "The design of S2DM can be summarized in these parts:\nObjects \u0026 Fields – Model the objects of interest (i.e., entities, events, features, etc.) and their fields (i.e., properties). Concept URIs – Concepts from the objects and fields are assigned future-proof URIs. Multi hierarchies – Concept URIs are reused to build arbitrary classification schemes. Variant IDs – Based on the metadata in the specification, a unique hashed ID is created. Specification registry – URIs and hashed IDs are combined into a specification registry. Capabilities – Possible operations to the data structures are specified.",
    "description": "The design of S2DM can be summarized in these parts:\nObjects \u0026 Fields – Model the objects of interest (i.e., entities, events, features, etc.) and their fields (i.e., properties). Concept URIs – Concepts from the objects and fields are assigned future-proof URIs. Multi hierarchies – Concept URIs are reused to build arbitrary classification schemes. Variant IDs – Based on the metadata in the specification, a unique hashed ID is created.",
    "tags": [],
    "title": "Approach overview",
    "uri": "/s2dm/1-approach-overview/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Tools",
    "content": "Under construction..",
    "description": "Under construction..",
    "tags": [],
    "title": "Command Line Interface (CLI)",
    "uri": "/s2dm/3-tools/3.1-cli/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Approach overview",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Objects \u0026 Fields",
    "uri": "/s2dm/1-approach-overview/1.1-objects-and-properties/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Data modeling guideline",
    "content": "Units Units are represented as enum values. For example:\nenum VelocityUnitEnum { KILOMETER_PER_HOUR METERS_PER_SECOND } The name of the enum itself refers to the quantity kind (e.g., Velocity). A set of commonly used units is provided in the file unit_enums.graphql.\n[!NOTE] It is planned to adopt and reuse an existing standard data model for units. At the moment, the units file is inspired by COVESA VSS Units file. The tentative model that will be used in the future is the QUDT units.\nCustom scalars Scalars in GraphQL are basically the datatypes to which a field resolves. GraphQL supports a few built-in scalars such as Int, Float, String, Boolean, and ID. It is possible to define custom ones. The file /spec/custom_scalars.graphql contains custom scalars that could be referenced in the model.\nCustom directives @instanceTag directive @instanceTag on OBJECT TODO: Add description and example\n@cardinality directive @cardinality(min: Int, max: Int) on FIELD_DEFINITION TODO: Add description and example\n@range directive @range(min: Float, max: Float) on FIELD_DEFINITION TODO: Add description and example\n@noDuplicates directive @noDuplicates on FIELD_DEFINITION Considering the following generic object:\ntype MyObject { field: \u003coutputType\u003e } By default, the GraphQL SDL let us express the following six combinations for output types in fields:\nCase Description outputType Nullable Singular Field A singular element that can also be null. NamedType Non-Nullable Singular Field A singular element that cannot be null. NamedType! Nullable List Field An array of elements. The array itself can be null. [NamedType] Non-Nullable List Field An array of elements. The array itself cannot be null. [NamedType]! Nullable List of Non-Nullable Elements An array of elements. The array itself can be null but the elements cannot. [NamedType!] Non-Nullable List of Non-Nullable Elements List and elements in the list cannot be null. [NamedType!]! Implicitly, lists here refer to an array of values that could be duplicated. In order to explicitly say that the intended content of the array should function as a set of unique values instead, the custom directive @noDuplicates is introduced.\ntype Person { nicknamesList: [String] # Array with possible duplicate values nicknamesSet: [String] @noDuplicates # Set of unique values } Common types Common enumeration sets In some cases, it is practical to refer to a particular set of values that might fit to multiple use cases. For example, the zone inside the cabin of a car could be re used by the Door and the Window It could be modeled as:\ntype InCabinZone { row: InCabinRowEnum! side: InCabinSide! } enum InCabinRowEnum { FRONT REAR } enum InCabinSide { DRIVER_SIDE PASSENGER_SIDE } Then, it can be referenced from:\nWindow { instance: InCabinZone ... } Door { instance: InCabinZone ... } Such common enumeration sets are available in the file /spec/common_enums.graphql.\nCommon objects of interest Under construction…",
    "description": "Units Units are represented as enum values. For example:\nenum VelocityUnitEnum { KILOMETER_PER_HOUR METERS_PER_SECOND } The name of the enum itself refers to the quantity kind (e.g., Velocity). A set of commonly used units is provided in the file unit_enums.graphql.\n[!NOTE] It is planned to adopt and reuse an existing standard data model for units. At the moment, the units file is inspired by COVESA VSS Units file. The tentative model that will be used in the future is the QUDT units.",
    "tags": [],
    "title": "Pre-defined elements",
    "uri": "/s2dm/2-data-modeling-guideline/2.1.-pre-defined-elements/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Tools",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Automation",
    "uri": "/s2dm/3-tools/3.2-automation/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Approach overview",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Concept URIs",
    "uri": "/s2dm/1-approach-overview/1.2-concept-uris/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Data modeling guideline",
    "uri": "/s2dm/2-data-modeling-guideline/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Data modeling guideline",
    "content": "Under construction..\n…model an object and/or a field? Simply use the GraphQL SDL. Object types start with type keyword.\ntype MyObject { someField: String # \u003c-- Built-in scalar as output anotherField: AnotherOutputType # \u003c-- Custom named type as output } Modeling Guide NOTE: This document explains how to contribute to an specific model (new or existing). If you want to contribute to the data modeling approach itself, then see the Contributing Guide instead.\nTODO: Work in progress…\nBasic building blocks We re use following established artifacts:\nFor the specification of data structures and possible operations on that data, S2DM re uses the GraphQL Schema Definition Language (SDL). The full feature set is available in the official GraphQL specification. For the specification of multiple classification schemes, S2DM uses the Simple Knowledge Organization System (SKOS). To learn more about them, please consult the official documentation. Modeling a new domain Identify the relevant object types (i.e., entities or classes). Examples: Vehicle, Person, etc. Specify an object type of each one (assuming it does not exist yet). Add fields to types to represent relationships. If the field resolves to a datatype, then assign an scalar. If the field connects to another object type, then assign it. Define the set of enum values. Add other metadata. Modeling an existing domain Extending an existing model Modifying an existing model Extending a type Deprecating elements It is possible to deprecate fields and enum values with the built-in directive @deprecated.\ntype Window { position: Int openness: Int @deprecated(reason: \"Use `position`.\") } To avoid breaking changes, GraphQL does not support the deprecation of types. To deprecate a complete type, simply deprecate all the fields or values inside.\ntype SomeDeprecatedObjectType { fieldOne: string @deprecated(reason: \"Use `MyNewType.fieldOne`.\") ... fieldN: string @deprecated(reason: \"Use `MyNewType.fieldN`.\") } type SomeDeprecatedEnum { ONE @deprecated(reason: \"Use `MyNewEnum`.\") ... TEN @deprecated(reason: \"Use `MyNewEnum`.\") } If you want to know more, click here to see the specification.\nModel versioning This simplified modeling approach suggests the use of the GraphQL schema language as a mechanism to model concepts as a graph in a simple manner. It does not mean that one must implement a GraphQL server (there might be some advantages to do so, though). It is purely about the language and the community tools that exist. According to the official documentation of the language, versioning the schema is considered a bad practice.\nWhile there’s nothing that prevents a GraphQL service from being versioned just like any other API, GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema…\n…GraphQL only returns the data that’s explicitly requested, so new capabilities can be added via new types or new fields on existing types without creating a breaking change. This has led to a common practice of always avoiding breaking changes and serving a versionless API.\nHowever, as the intention is to model a simple conceptual semantic model and not the full API itself, versioning is possible and special care must be given to the rule set.\nTODO: Work in progress…",
    "description": "Under construction..\n…model an object and/or a field? Simply use the GraphQL SDL. Object types start with type keyword.\ntype MyObject { someField: String # \u003c-- Built-in scalar as output anotherField: AnotherOutputType # \u003c-- Custom named type as output } Modeling Guide NOTE: This document explains how to contribute to an specific model (new or existing). If you want to contribute to the data modeling approach itself, then see the Contributing Guide instead.",
    "tags": [],
    "title": "How to...?",
    "uri": "/s2dm/2-data-modeling-guideline/2.2-how-to/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Approach overview",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Multi hierarchies",
    "uri": "/s2dm/1-approach-overview/1.3-multi-hierarchies/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Tools",
    "uri": "/s2dm/3-tools/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "Below are some examples of how the Simplified Semantic Data Modeling (S2DM) approach can be applied in different areas or use cases. Each example is linked to its corresponding folder in the repository for further exploration.\nExample Use Cases Multiple Classification Schemes: Enabling multiple classification schemes using SKOS. Multiple Domains: Covering cross-references across different domains. Seat Capabilities: Specifying possible operations linked to seat-related objects or entities. Seat to VSS Mapping: Mapping modular seat specifications to the Vehicle Signal Specification (VSS). Specification History Registry: Tracking changes and maintaining a registry of specification history. CLI Tool Examples Version Bump CLI Examples: Demonstrating automated version bumping based on GraphQL schema changes using the s2dm check version-bump command. If your use case is not covered by the presented examples, feel free to get in touch. If this approach suits your use case, we will add it here.",
    "description": "Below are some examples of how the Simplified Semantic Data Modeling (S2DM) approach can be applied in different areas or use cases. Each example is linked to its corresponding folder in the repository for further exploration.\nExample Use Cases Multiple Classification Schemes: Enabling multiple classification schemes using SKOS. Multiple Domains: Covering cross-references across different domains. Seat Capabilities: Specifying possible operations linked to seat-related objects or entities. Seat to VSS Mapping: Mapping modular seat specifications to the Vehicle Signal Specification (VSS).",
    "tags": [],
    "title": "Examples",
    "uri": "/s2dm/4-examples/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Approach overview",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Variant IDs",
    "uri": "/s2dm/1-approach-overview/1.4-variant-ids/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "FAQs",
    "uri": "/s2dm/5-faqs/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Approach overview",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Specification registry",
    "uri": "/s2dm/1-approach-overview/1.5-spec-registry/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Approach overview",
    "content": "Under construction…",
    "description": "Under construction…",
    "tags": [],
    "title": "Capabilities",
    "uri": "/s2dm/1-approach-overview/1.6-capabilities/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Examples",
    "content": "This section contains examples demonstrating different scenarios for the s2dm check version-bump command, based on GraphQL Inspector’s change detection.\nOverview The version-bump command analyzes GraphQL schema changes and recommends the appropriate semantic version bump:\nNo version bump: Identical schemas Patch/Minor bump: Non-breaking changes (new optional fields, enum values) Major bump: Breaking changes (removed fields, type changes) Dangerous changes: Potentially problematic but not immediately breaking Examples 1. No Version Bump Needed Command:\ns2dm check version-bump -s no-change.graphql -p base.graphql Expected Output:\nNo version bump needed Scenario: Both schemas are identical, no changes detected.\n2. Non-Breaking Change (Minor/Patch Bump) Command:\ns2dm check version-bump -s non-breaking.graphql -p base.graphql Expected Output:\nPatch version bump needed Changes:\nAdded new optional fields: Vehicle.owner, Vehicle.mileage, Engine.fuelEfficiency These changes are backwards compatible and won’t break existing clients.\n3. Dangerous Change Command:\ns2dm check version-bump -s dangerous.graphql -p base.graphql Expected Output:\nMinor version bump needed Changes:\nAdded new enum value: EngineType.HYDROGEN Note: GraphQL Inspector may classify these as dangerous changes depending on configuration, but they’re typically backwards compatible due to default values.\n4. Breaking Change (Major Bump) Command:\ns2dm check version-bump -s breaking.graphql -p base.graphql Expected Output:\nDetected breaking changes, major version bump needed. Please run diff to get more details Changes:\nRemoved field: Vehicle.color Changed field type: Vehicle.owner from String to Int Changed field type: Engine.displacement from Float to Int Removed enum value: EngineType.HYBRID These changes will break existing clients that depend on the removed/changed fields.\nUnderstanding Change Types Non-Breaking Changes ✅ Adding new optional fields Adding new enum values Adding new types Adding new queries/mutations Adding descriptions/deprecation notices Dangerous Changes ⚠️ Adding arguments to existing fields (with defaults) Changing field descriptions significantly Adding interfaces to existing types Breaking Changes ❌ Removing fields, types, or enum values Changing field types incompatibly Making optional fields required Removing or changing arguments Changing field nullability (nullable to non-nullable) Running the Examples To test these examples:\n# Navigate to the test data directory cd tests/data # Test each scenario s2dm check version-bump -s no-change.graphql -p base.graphql s2dm check version-bump -s non-breaking.graphql -p base.graphql s2dm check version-bump -s dangerous.graphql -p base.graphql s2dm check version-bump -s breaking.graphql -p base.graphql Additional Commands For more detailed analysis, use the diff command:\ns2dm diff graphql -s breaking.graphql -v base.graphql This will provide a comprehensive breakdown of all changes detected between the schemas.\nPipeline Usage For pipeline automation, use the --output-type flag to get machine-readable output:\n# Returns: none, patch, minor, or major VERSION_BUMP=$(s2dm check version-bump -s new-schema.graphql -p old-schema.graphql --output-type) # Example pipeline usage: if [[ \"$VERSION_BUMP\" == \"major\" ]]; then echo \"Breaking changes detected, requires manual review\" exit 1 elif [[ \"$VERSION_BUMP\" == \"minor\" ]]; then echo \"Minor version bump needed\" # bump-my-version bump minor elif [[ \"$VERSION_BUMP\" == \"patch\" ]]; then echo \"Patch version bump needed\" # bump-my-version bump patch else echo \"No version bump needed\" fi Return Values none: No changes detected patch: Non-breaking changes only (✔ symbols in diff) minor: Dangerous changes detected (⚠ symbols in diff) major: Breaking changes detected (✖ symbols in diff)",
    "description": "This section contains examples demonstrating different scenarios for the s2dm check version-bump command, based on GraphQL Inspector’s change detection.\nOverview The version-bump command analyzes GraphQL schema changes and recommends the appropriate semantic version bump:\nNo version bump: Identical schemas Patch/Minor bump: Non-breaking changes (new optional fields, enum values) Major bump: Breaking changes (removed fields, type changes) Dangerous changes: Potentially problematic but not immediately breaking Examples 1. No Version Bump Needed Command:",
    "tags": [],
    "title": "Version Bump CLI Examples",
    "uri": "/s2dm/4-examples/version-bump-cli/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Others",
    "content": "Simplified Semantic Data Modeling (S2DM) - Approach Primer Table of Contents Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Vehicle Signal Specification has been an alternative but requires improvements Design principles Problem Requirements Goal Artifact Proposed solution approach General workflow Idea (1): Maintain Entity and Property sets Idea (2): Maintain a set of reusable labels Idea (3): Construct unique IDs Idea (4): Allow arbitrary hierarchies for different classification criteria Other ideas Examples Special considerations Special cross references Model versioning Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Subject Matter Experts (SMEs) are often not familiar with data modeling, nor are they following best practices to formalize their knowledge. This lack in expertise can be problematic when they are in charge of expanding and maintaining a certain controlled vocabulary that will be used in real systems at the enterprise level.\nVehicle Signal Specification has been an alternative but requires improvements When it comes to vehicle data, the Vehicle Signal Specification (VSS) has been offering an easy-to-follow approach to enable SMEs contribute to a controlled vocabulary of high-level vehicle properties (e.g., Speed, Acceleration, etc.).\nVehicle Signal Specification (VSS) is a controlled vocabulary for the properties of a car organized in a hierarchical tree. To learn more about VSS, please visit the official documentation page.\nThe VSS modeling approach has been well received by SMEs who have been extending the list of properties both publicly at the COVESA alliance and internally at BMW. However, this approach has reached its limits on what one can express with it. Among the limitations, is the fact that VSS uses a custom file extension .vspec that referes to files written in YAML with a custom syntax. The language used in vspec, as of December 2024, does not support cross references. Thus, it is not possible to model multiple inter-connected domains.\nIf you want to learn more about the current limitations of VSS, please visit these resources:\nDefining the COVESA data modeling strategy and its associated artifacts Towards a Vehicle DATA specification Vehicle DATA Specification The reference mapping between the Vehicle Signal Specification (VSS) and this S2DM approach is documeted in /docs/s2dm_vss_mapping.md.\nDesign principles Problem Disparate vehicle data models that lack proper semantics. Requirements Criteria Requirement Simplicity Modeling approach is easy to follow. Its representation is not verbose. It is friendly for anyone new to the area. It is easy to add new concepts. Technology agnosticism Data model can be used with any downstream technology (e.g., by exporting it into multiple schemas). Modularity Data model can be split into multiple (reusable) small pieces. Scalability \u0026 Maintainability Model can scale up (e.g., concepts are extended). It can be easily maintained (e.g., changes and extensions are possible). Metadata resource uniqueness Concepts in the data model are uniquely identifiable with future-proof ids (e.g., by the use of International Resource Identifiers (IRIs)). Support for multiple classification schemes Polyhierarchies are supported to classify the terms in the vocabulary with different classification criteria (i.e., useful for data catalogs). Support for cross-domain references Multiple cross-referenced domains are supported natively by the language (useful for contextual data). Community \u0026 Tools Data model can be used in multiple up-to-date public tools. Modeling approach is based on a language that is already established in the open community. Goal To minimize the effort needed to develop, extend, and maintain vehicle-related semantic data models. Artifact A guideline on how to model vehicle-related data with proper semantics and good practices. Proposed solution approach General workflow A simplified approach (see figure’s left side) could be the adequate bridge between the ideal enterprise metadata management and the actual use of a domain data model in an application. Specially in cases where SMEs are actively extending a set of data structures that are needed in practice. Also, when alliances or consortiums consist of multiple external stakeholders.\nOverall, a SME should be able to intuitively search and find the data of interest via a data catalog. If the desired data is found, tools must allow the export of it into the structure needed in the application. In the case that no existing data matches his needs, simple steps must allow the modeling of the missing concepts. To that end, such a process is proposed with the following ideas:\nIdea (1): Maintain Entity and Property sets In an application, most of the value is centered around what one can read or write. Thus, the most granular structure corresponds always to a certain Property (aka., characteristic, attribute, etc.). For example: the position of the window, the speed of a vehicle, the angle of the steering wheel. All of them are assotiated to a particular datatype, such as Integer, String, etc. Then actual values of those properties can have dynamic (i.e., data streams) or static behavior.\nProperties belong to some Entity that is of interest for our application. For example: Window, Vehicle, SteeringWheel, etc. So, an Entity can contain a collection of properties.\nThe principal idea here is to maintain a set of entities and their assotiated properties.\nIdea (2): Maintain a set of reusabel labels In some cases, there are entities that can have multiple instances. For example, A vehicle might not have one but multiple doors, windows, seats, batteries, tires, etc. Hence, it becomes useful to avoid repetition in the modeling by allowing the specification of reusable labels. A list of labels, such as InCabinZone, could contain the options FRONT_LEFT, and FRONT_RIGHT. These could be used directly to specify a particular Door, Windows, and Seat.\nIdea (3): Construct unique IDs To foster reusability and avoid naming conflicts, a rule set must be enforced. The minimum constraints must be:\nA namespace (ns) must be unique and future-proof. Within a namespace (ns), the name of an Entity must be unique. Within a namespace (ns), the name of an Enum must be unique. Within an Entity, the name of a Property must be unique. In the case of GraphQL schema language these constraints are supported. One can concatenate the elements to create International Resource Identifiers (IRIs)\nPREFIX ns: \u003cmynamespacehere\u003e ns:Door ns:Door.position ns:Door.isOpen Then, IRIs can be used when defining the schema in the application. For example, a json schema could look like:\n{ \"type\": \"object\", \"properties\": { \"door\": { \"implementedConcept\": \"ns:Door\", \"type\": \"object\", \"properties\": { \"position\": {\"type\": \"int\"}, \"isOpen\": {\"type\": \"boolean\"} }, } }, } Idea (4): Allow arbitrary hierarchies for different classification criteria As the Entity and Property sets grow over time, proper information classification becomes essential. The most tangible value of this organization is visible in any online shop. There, a faceted search is the default tool for filtering the available data with specific criteria. The same principle can be applied here.\nFor example, the Window entity can be classified by its physical position (Vehicle.Cabin.Door.Window), its principle of movement (MovablePart.UniDimensionalMove.Window), its material (Piece.GlassedPiece.Window), and by other criteria.\nThe Simple Knowledge Organization System (SKOS) is a well-established standard to achieve such classifications.\nIdea (5): Specify possible interactions The entity and property sets (of idea (1)) can be complemented with an specification of the set of possible operations on them (i.e., interactions or actions). For example:\nDomain Operation Seat Get the position of all seats. Seat Save a seat position to memory. Seat Control the heating mode of a seat. Climate Turn on/off the AC. Climate Set the temperature. Climate Get the fan speed per zone. Other ideas: TODO: Conversational tools, versioning, etc.\nExamples Refer to the examples folder.\nSpecial considerations The following cases require special treatments.\nDilemma: Property as field or as object type Here’s the markdown summarizing the three cases for your dilemma:\nCase 1: Scalar Field type Vehicle { speed: Int } Pros:\nSimple and concise representation. Easy to read and understand for straightforward use cases. Suitable for static properties that do not require additional metadata or complexity. Cons:\nLimited extensibility: Adding metadata (e.g., units like “km/h”) or additional attributes (e.g., timestamp) requires refactoring. Not future-proof: If the property evolves to include more details, significant schema changes are needed. Cannot represent complex relationships or metadata. Case 2: Dedicated Object Type type Vehicle { speed: VehicleSpeed } type VehicleSpeed { value: Int unit: String timestamp: String } Pros:\nHighly extensible: Allows adding metadata like unit or timestamp without breaking the schema. Better suited for complex properties: Can easily accommodate additional fields like ranges or error margins. Future-proof: Supports evolving requirements without major schema changes. Cons:\nMore verbose: Introduces additional layers of nesting, making the schema longer and more complex. Overhead for simple properties: Feels excessive for straightforward fields like speed. Harder to read and maintain for basic use cases. Case 3: Reusable Property Type type Vehicle { speed: IntProperty } type IntProperty { value: Int unit: String timestamp: String } Pros:\nReusability: The IntProperty type can be used across multiple fields (e.g., speed, weight, etc.), ensuring consistency and reducing duplication. Extensible: Like Case 2, it supports adding metadata or attributes without schema refactoring. Consistent: Standardizes the representation of similar properties across the schema. Future-proof: Accommodates evolving requirements while maintaining schema clarity. Cons:\nOverhead for simple properties: Adds complexity for fields that don’t require metadata. Generic naming: May feel less descriptive compared to dedicated types like VehicleSpeed. Potential for overgeneralization: If properties diverge significantly, the reusable type may become too generic. Recommendation Use Case 1 for simple, static properties that are unlikely to evolve or require metadata. Use Case 2 for properties that are unique and require specific metadata or complex structures. Use Case 3 for properties that share common metadata or structures across the schema, ensuring reusability and consistency. For vehicle-related information, Case 3 with a reusable type like IntProperty is often the best choice, as it balances extensibility, reusability, and clarity.\nEnums’ datatypes In GraphQL, enums are typically used to define a set of allowed values for a field. These values are usually represented as strings, such as [FIRST, SECOND, ...]. However, GraphQL enums are not limited to strings conceptually; they can represent any discrete set of values.\nIf your model defines “allowed” values as integers, like [0, 1, 2, ...], you can still use GraphQL enums to represent them. Internally, GraphQL will treat these enum values as strings in the schema, but you can map them to integers in your application logic.\nenum TheAllowedValues { ZERO ONE TWO } In your application, you can map ZERO to 0, ONE to 1, and so on. This approach allows you to enforce a fixed set of values while maintaining flexibility in how they are interpreted in your code.\nSpecial cross references GraphQL schema language excels in defining the structure of data models in a clear and understandable way. It provides robust elements such as types, fields within types, nested objects, and enumerations. These features allow for a well-organized and precise representation of data structures. However, it has limitations such as restricted cross-references, where linking fields to other fields directly is not possible.\nLet us assume our model has the concepts Window.position, AC.temperature, AC.isOn, Sunroof.position. In the GraphQL schema language, it is not possible to say that the Person.perceivedTemperature can be modified by acting on these properties.\ntype Window { position: Int } type AC { temperature: Float isOn: Boolean } type Sunroof { position: Int } type Person { perceivedTemperature: Int # I want to say that this property might be affected by acting on the others pTemp: PTem } type PTemp{ affectedByProp: Property value: String! } type Property { objectName: String! fieldName: String! } Option 1 - Instance data file An alternative would be to define the schema as usual, and then write another instance data file with concrete instance data that represents the connections. For example, that the perceived temperature is affected by Window.position, AC.temperature, AC.isOn, Sunroof.position.\nOption 2 - Enums with URIs However, the following is possible and supported by the language out of the box by using nested objects:\ntype Person { perceivedTemperature: PerceivedTemperature } type PerceivedTemperature { temperature: Int modifiableBy: [perceivedTemperatureModifiersEnum] } enum perceivedTemperatureModifiersEnum { ns:Window.position ns:AC.temperature ns:AC.isOn ns:Sunroof.position } Option 3 - using directives\n```graphql directive @affectedBy(object: String!, field: String!) on FIELD_DEFINITION type Person { perceivedTemperature: Int @affectedBy(object: \"Window\", field: \"position\") } type Window { position: Int }",
    "description": "Simplified Semantic Data Modeling (S2DM) - Approach Primer Table of Contents Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Vehicle Signal Specification has been an alternative but requires improvements Design principles Problem Requirements Goal Artifact Proposed solution approach General workflow Idea (1): Maintain Entity and Property sets Idea (2): Maintain a set of reusable labels Idea (3): Construct unique IDs Idea (4): Allow arbitrary hierarchies for different classification criteria Other ideas Examples Special considerations Special cross references Model versioning Background Why do we need such an approach?",
    "tags": [],
    "title": "Approach primer",
    "uri": "/s2dm/others/approach_primer/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling \u003e  Others",
    "content": "Basic principle The idea is that multiple systems in the physical layer (e.g., databases, streaming platforms, applications, etc.) can share the same concepts. However, instead of arbitrarily modeling domains in the physical layer, the purpose is to have a unique way for specifying the concepts of common interest and its organizing principles in such a way that they are reused. This principle is a core part of a data-centric architecture, reducing undesired duplications and software waste when it is systematically applied.\ngraph LR subgraph ConceptualLayer Person Vehicle ParkingLot end subgraph PhysicalLayer Database StreamingPlatform Application Other end ConceptualLayer --\u003e Database ConceptualLayer --\u003e StreamingPlatform ConceptualLayer --\u003e Application ConceptualLayer --\u003e Other In this sense, S2DM is an approach to specify those concepts of interest systematically. A more generic (and elaborated) diagram looks like the following:\ngraph LR subgraph Conceptual layer spec_file_1.graphql spec_file_2.graphql spec_file_N.graphql subgraph S2DM Tools Composer Exporter Other end end subgraph Physical layer App_SHACL App_YAML App_JSON App_Other end spec_file_1.graphql --GraphQL schema 1--\u003e Composer spec_file_2.graphql --GraphQL schema 2--\u003e Composer spec_file_N.graphql --GraphQL schema N--\u003e Composer Composer --Merged GraphQL schema--\u003e Exporter Composer --Merged GraphQL schema--\u003e Other Exporter --VSPEC--\u003e App_YAML Exporter --SHACL--\u003e App_SHACL Exporter --JSON schema--\u003e App_JSON Exporter --Other?--\u003e App_Other",
    "description": "Basic principle The idea is that multiple systems in the physical layer (e.g., databases, streaming platforms, applications, etc.) can share the same concepts. However, instead of arbitrarily modeling domains in the physical layer, the purpose is to have a unique way for specifying the concepts of common interest and its organizing principles in such a way that they are reused. This principle is a core part of a data-centric architecture, reducing undesired duplications and software waste when it is systematically applied.",
    "tags": [],
    "title": "Basic principle",
    "uri": "/s2dm/others/basic_principle/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/s2dm/categories/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Others",
    "uri": "/s2dm/others/index.html"
  },
  {
    "breadcrumb": "",
    "content": "The Simplified Semantic Data Modeling (S2DM) is an approach for modeling data of multiple domains. It is simple in the sense that any Subject Matter Expert (SME) could contribute to a controlled vocabulary with minimal data modeling expertise. Likewise, it is semantic in the sense that it specifies meaningful data structures, their cross-domain relationships, and arbitrary classification schemes.\n[!NOTE] Bear in mind the word Simplified in the name. This approach aims to foster the adoption of (some) good data modeling practices. It does not intent to re-invent, nor to replace long-standing standards, such as those of the Semantic Web. Hence, it does not incorporate advanced reasoning capabilities or comprehensive ontologies typically associated with traditional semantic data modeling.\nThe figure above ilustrates the role of the S2DM approach. One can distinghish three areas: the re-use of existing resources (left), the artifacts offered by S2DM (center), and the resulting domain data model created and maintained with S2DM artifacts (right).\nGetting started Get a basic understanding of the S2DM approach. Model your domain following the S2DM data modeling guideline. Maintain your domain model with the support of the provided S2DM tools. [!TIP] S2DM artifacts are based on the following existing resources. Getting familiar with them is recomended.\nModeling languages and vocabularies GraphQL Schema Definition Language (SDL) - It provides a clear, human-readable syntax for defining data structures and relationships, making it easy for SMEs to understand and use without requiring deep technical expertise. Simple Knowledge Organization System (SKOS) - SKOS is an RDF-basedd vocabulary that offers a straightforward framework for creating and managing hierarchical classifications and relationships between concepts, facilitating the organization and retrieval of knowledge in a way that is both intuitive and semantically rich. Tools rdflib - To work with RDF data in Python (i.e., SKOS). graphql-core - To work with GraphQL schemas in Python (i.e., SDL). Others",
    "description": "The Simplified Semantic Data Modeling (S2DM) is an approach for modeling data of multiple domains. It is simple in the sense that any Subject Matter Expert (SME) could contribute to a controlled vocabulary with minimal data modeling expertise. Likewise, it is semantic in the sense that it specifies meaningful data structures, their cross-domain relationships, and arbitrary classification schemes.\n[!NOTE] Bear in mind the word Simplified in the name. This approach aims to foster the adoption of (some) good data modeling practices.",
    "tags": [],
    "title": "Simplified Semantic Data Modeling",
    "uri": "/s2dm/index.html"
  },
  {
    "breadcrumb": "Simplified Semantic Data Modeling",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/s2dm/tags/index.html"
  }
]
